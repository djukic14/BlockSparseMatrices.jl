var documenterSearchIndex = {"docs":
[{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"apiref/#BlockSparseMatrices.BlockSparseMatrix","page":"API Reference","title":"BlockSparseMatrices.BlockSparseMatrix","text":"struct BlockSparseMatrix{T,M,D} <: AbstractBlockMatrix{T}\n\nSparse block matrix.\n\nFields\n\nblocks::Vector{M}: Dense blocks.\nsize::Tuple{Int,Int}: Size of the matrix.\nforwardbuffer::Vector{T}: ???.\nadjointbuffer::Vector{T}: ???.\nbuffer::Vector{T}: ???.\nrowindexdict::D: Global rowindices of dense blocks.\ncolindexdict::D: Global columnindices of dense blocks.\nthreadsafecolors::Vector{Vector{Int}}: Coloring of dense blocks for multithreaded matrix-vector product.\nntasks::Int: Threads used for the matrix Vector product.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BlockSparseMatrices.SymmetricBlockMatrix","page":"API Reference","title":"BlockSparseMatrices.SymmetricBlockMatrix","text":"SymmetricBlockMatrix{T,DM,M,D} <: AbstractBlockMatrix{T}\n\nSymmetric sparse block matrix.\n\nFields\n\ndiagonals::Vector{DM}: Dense blocks on the diagonal of the matrix.\noffdiagonals::Vector{M}: Dense blocks not on the diagonal.\nsize::Tuple{Int,Int}: Size of the matrix.\nforwardbuffer::Vector{T}: ???.\nadjointbuffer::Vector{T}: ???.\nbuffer::Vector{T}: ???.\ndiagonalrowindexdict::D: Global rowindices of diagonal dense blocks.\ndiagonalcolindexdict::D: Global columnindices of offdiagonal dense blocks.\noffdiagonalrowindexdict::D: Global rowindices of diagonal dense blocks.\noffdiagonalcolindexdict::D: Global columnindices of offdiagonal dense blocks.\nthreadsafecolors::Vector{Vector{Int}}: Coloring of dense blocks for multithreaded matrix-vector product.\nntasks::Int: Threads used for the matrix Vector product.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BlockSparseMatrices.DenseMatrixBlock","page":"API Reference","title":"BlockSparseMatrices.DenseMatrixBlock","text":"DenseMatrixBlock{T,M,RC} <: AbstractMatrixBlock{T}\n\nDense block in a sparse blockmatrix.\n\nFields\n\nmatrix::M: Matrix.\nrowindices::RC: Global row indices.\ncolindices::RC: Global column indices.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"apiref/#BlockSparseMatrices.findcolor!","page":"API Reference","title":"BlockSparseMatrices.findcolor!","text":"findcolor!(\n    blockid::Int,\n    threadsafecolors::AbstractArray,\n    blocks::Vector{M};\n    threadsafecheck=isthreadsafe(),\n    color=1,\n) where {M}\n\nAssigns recursively threadsafe color to the dense block with index blockid.\n\nArguments\n\nblockid::Int: Index of block.\nthreadsafecolors::AbstractArray: Contains assigned blocks.\nblocks::Vector{M}: Vector with all blocks.\nthreadsafecheck=isthreadsafe(): Threadsafe check, differs between symmetric and non-symmetric matrix.\ncolor=1: Currently tested color, increased if block does not fit in color.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BlockSparseMatrices.islessinordering","page":"API Reference","title":"BlockSparseMatrices.islessinordering","text":"islessinordering(blocka::AbstractMatrixBlock, blockb::AbstractMatrixBlock)\n\nSorting rule for AbstractMatrixBlock objects\n\n\n\n\n\n","category":"function"},{"location":"details/#Further-Details","page":"Further Details","title":"Further Details","text":"","category":"section"},{"location":"details/#Matrix-Vector-Product","page":"Further Details","title":"Matrix-Vector Product","text":"","category":"section"},{"location":"details/","page":"Further Details","title":"Further Details","text":"For the multithreaded matrix-vector product","category":"page"},{"location":"details/","page":"Further Details","title":"Further Details","text":"bm y = bm A bm x","category":"page"},{"location":"details/","page":"Further Details","title":"Further Details","text":"where bm A is a BlockSparseMatrix or a SymmetricBlockMatrix, bm x a random vector, and bm y the solution vector, we use a coloring scheme to allow a multithreaded matrix-vector product without unnecessary allocations. Each block is assigned to one color such that all blocks of the same color do not share common row or column indices.  This allows to evaluate all matrix-vector products within one color parallel without allocating multiple solution vectors bm y. ","category":"page"},{"location":"details/","page":"Further Details","title":"Further Details","text":"The coloring scheme works best for large numbers of dense blocks.","category":"page"},{"location":"details/","page":"Further Details","title":"Further Details","text":"The row and column indices of blocks should not be overlapping. Only unique sets of row and column indices are supported as well as row and column indices that are subsets of the indices of other blocks. ","category":"page"},{"location":"details/#Example","page":"Further Details","title":"Example","text":"","category":"section"},{"location":"details/","page":"Further Details","title":"Further Details","text":"Example of the coloring scheme using four groups. Each color can be evaluated using multiple threads with a single solution vector ","category":"page"},{"location":"details/","page":"Further Details","title":"Further Details","text":"\n\n<div style=\"display: flex; gap: 20px; justify-content: space-between;\">\n\n  <figure style=\"width: 49%; margin: 0;\">\n    <img src=\"../assets/nocolor.svg\" style=\"width: 100%; height: auto;\" />\n    <figcaption style=\"text-align: center; margin-top: 5px;\">Figure 1: Dense blocks in a block sparse matrix. </figcaption>\n  </figure>\n\n  <figure style=\"width: 49%; margin: 0;\">\n    <img src=\"../assets/logo.svg\" style=\"width: 100%; height: auto;\" />\n    <figcaption style=\"text-align: center; margin-top: 5px;\">Figure 2: Colored dense blocks.</figcaption>\n  </figure>\n\n</div>","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the main branch. Before doing so please: ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(BlockSparseMatrices))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"BlockSparseMatrices.jl\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"BlockSparseMatrices\"; coverage=true, julia_args=[\"-t 4\"])\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(BlockSparseMatrices) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"BlockSparseMatrices.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the BlockSparseMatrices.lcov.info file in the settings.","category":"page"},{"location":"manual/#General-Usage","page":"Manual","title":"General Usage","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The basic usage of this package is provided in the following examples.","category":"page"},{"location":"manual/#Example:-Block-Sparse-Matrix","page":"Manual","title":"Example: Block Sparse Matrix","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using BlockSparseMatrices\n\n# define dense matrix blocks\nmat1 = randn(ComplexF64, 2, 2)\nblock1 = BlockSparseMatrices.DenseMatrixBlock(mat1, 1:2, 1:2)\nmat2 = randn(ComplexF64, 3, 3)\nblock2 = BlockSparseMatrices.DenseMatrixBlock(mat2, 3:5, 3:5)\n\nblockmatrix = BlockSparseMatrix([block1, block2], 5, 5)","category":"page"},{"location":"manual/#Example:-Symmetric-Block-Sparse-Matrix","page":"Manual","title":"Example: Symmetric Block Sparse Matrix","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using BlockSparseMatrices\n\n# define dense matrix blocks\nmat1 = randn(ComplexF64, 2, 2)\ndiagonalblock = BlockSparseMatrices.DenseMatrixBlock(mat1, 1:2, 1:2)\nmat2 = randn(ComplexF64, 3, 3)\noffdiagonalblock = BlockSparseMatrices.DenseMatrixBlock(mat2, 7:9, 7:9)\n\ndiagonalmatrix = SymmetricBlockMatrix([diagonalblock], [offdiagonalblock], 9, 9)","category":"page"},{"location":"#BlockSparseMatrices.jl","page":"Introduction","title":"BlockSparseMatrices.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides an abstract matrix type for block structured matrices, where the majority of the matrix is zero.  This is in general the case for the near interactions in fast methods for the boundary element method. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Installing BlockSparseMatrices is done by entering the package manager (enter ] at the julia REPL) and issuing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add BlockSparseMatrices ","category":"page"}]
}
